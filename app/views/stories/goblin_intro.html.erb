<h1>ゴブリンとの遭遇</h1>

<div class="story-text-block">
  <p class="story-line is-narrator js-line" data-line-id="narrator_1">
    あなたは、まず目の前の脅威に集中することにした。森の奥の声は気になるが、倒れた馬車とゴブリンたちを放置しておくわけにもいかない。
  </p>

  <p class="story-line is-fairy js-line" data-line-id="fairy_1">
    「分かった。まずはこのゴブリンたちから片付けよう。あの馬車の人たちが無事かどうか、気になるしね。」
  </p>

  <p class="story-line is-narrator js-line" data-line-id="narrator_2">
    足音を殺し、ゴブリンたちとの距離を少しずつ詰めていく。しかし、やがて彼らもこちらの存在に気づき、ぎょろりとした目を向けてきた。
  </p>

  <p class="story-line is-goblin js-line" data-line-id="goblin_1">
    「ゲリャッ、ゲリャッ！！」
  </p>

  <p class="story-line is-fairy js-line" data-line-id="fairy_2">
    「流石にここまで近づいたら、気づいたみたい。気をつけてね、あの子たち、集団で来ると結構やっかいだから。」
  </p>

  <p class="story-line is-narrator js-line" data-line-id="narrator_3">
    ゴブリンたちは歯をむき出しにしながら武器を振り上げ、一斉に飛びかかってくる。ここから――最初の本格的な戦いが始まる。
  </p>
</div>

<hr>

<p>「ゴブリン達との戦闘に入る」</p>
<%= link_to "戦闘開始", new_battle_path(player_id: @player.id, enemy_type: "goblin"), class: "btn" %>

<audio id="scene-audio"></audio>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    // 再生順
    const order = [
      "narrator_1",
      "fairy_1",
      "narrator_2",
      "goblin_1",
      "fairy_2",
      "narrator_3"
    ];

    // .js-line 要素を全部拾って、data-line-id をキーに保持
    const lineEls = {};
    document.querySelectorAll(".js-line").forEach(function (el) {
      const id = el.dataset.lineId;
      if (id) lineEls[id] = el;
    });

    function setActive(lineId) {
      // いったん全て非アクティブに
      Object.values(lineEls).forEach(function (el) {
        el.classList.remove("is-speaking");
      });

      // 対象行にクラス付与＆スクロール
      if (lineId && lineEls[lineId]) {
        const el = lineEls[lineId];
        el.classList.add("is-speaking");
        el.scrollIntoView({ behavior: "smooth", block: "center" });
      }
    }

    let currentIndex = -1;
    const audio = new Audio();

    // ★ 音声キャッシュ
    const voiceCache = {};

    function preloadVoice(lineId) {
      if (voiceCache[lineId]) {
        // すでにキャッシュ済み
        return Promise.resolve();
      }

      const url =
        "/voices/goblin_intro?line=" +
        encodeURIComponent(lineId) +
        "&t=" +
        Date.now();

      return fetch(url)
        .then(function (res) {
          return res.arrayBuffer();
        })
        .then(function (buf) {
          const blob = new Blob([buf], { type: "audio/wav" });
          const objectUrl = URL.createObjectURL(blob);
          voiceCache[lineId] = objectUrl;
        });
    }

    function playNext() {
      currentIndex += 1;

      // 全部再生し終えたら終了
      if (currentIndex >= order.length) {
        setActive(null);
        return;
      }

      const lineId = order[currentIndex];
      setActive(lineId);

      const cached = voiceCache[lineId];

      if (cached) {
        audio.src = cached;
        audio.play().catch(function (err) {
          console.warn("play error:", err);
          const btn = document.getElementById("goblin-play");
          if (btn) btn.style.display = "inline-block";
        });
      } else {
        // まれにプリロードが間に合わなかった場合の保険
        const url =
          "/voices/goblin_intro?line=" +
          encodeURIComponent(lineId) +
          "&t=" +
          Date.now();
        audio.src = url;
        audio.play().catch(function (err) {
          console.warn("play error (fallback):", err);
          const btn = document.getElementById("goblin-play");
          if (btn) btn.style.display = "inline-block";
        });
      }
    }

    // 1個終わるごとに次を再生
    audio.addEventListener("ended", playNext);

    // 再生ボタン（任意）
    const btn = document.getElementById("goblin-play");
    if (btn) {
      btn.addEventListener("click", function () {
        btn.style.display = "none";
        currentIndex = -1;
        playNext();
      });
    }

    // ★ 最初の1行だけプリロードしてから自動再生開始
    preloadVoice(order[0]).then(function () {
      currentIndex = -1;
      playNext();
    });

    // 残りの行はバックグラウンドでプリロード
    order.slice(1).forEach(function (lineId) {
      preloadVoice(lineId);
    });
  });
</script>